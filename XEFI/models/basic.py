"""
Module for the XEFI calculation of a basic set of layers.
"""

import numpy as np, numpy.typing as npt
from typing import Callable
from XEFI.models.results import BaseResult
import warnings
import scipy.constants as sc
import matplotlib.pyplot as plt

en2wav: float = sc.h * sc.c / sc.e * 1e10
r"""
Conversion factor from energy in eV to wavelength in angstroms.

.. math::
    \lambda = (h \times c) / (E \times e)
    wav = en2wav / E

"""
en2wvec: float = 2 * sc.pi / en2wav
r"""
Conversion factor from energy in eV to wavevector in inverse angstroms.

.. math::
    \lambda = (h \times c) / (E \times e) * 1e10
    \lambda = en2wav / E
    \k = 2 \pi / (\lambda)
    \k = en2wvec * E
"""

# Support for KKCalc
try:
    from kkcalc.models.polynomials import asp_complex

    has_KKCalc = True
except ImportError:
    has_KKCalc = False


class BasicResult(BaseResult):
    """
    Result class for the basic XEF model, inheriting from BaseResult.

    This class has the same properties as BaseResult, but is generated by the basic XEF model.
    """


class BasicRoughResult(BasicResult):
    """
    Result class for the basic XEFI model with roughness, inheriting from BaseResult.

    This class extends the BaseResult to include additional properties specific to the basic model,
    in particular the roughness contributions to the modified Fresnel coefficients.

    Attributes
    ----------
    ...
    """

    def __init__(self):
        # Declare the properties
        self.z_roughness: npt.NDArray[np.floating] | None = None
        """The roughness of the (N) interfaces in Angstroms (Å)."""
        self.rough_S: npt.NDArray[np.complex128] | None = None
        """Roughness reflection factor for each energy, angle and interface (L, M, N)"""
        self.rough_T: npt.NDArray[np.complex128] | None = None
        """Roughness transmission factor for each energy, angle and interface (L, M, N)"""
        self.fresnel_r_rough: npt.NDArray[np.complex128] | None = None
        """The Fresnel reflection coefficients with roughness for each energy, angle and interface (L, M, N)"""
        self.fresnel_t_rough: npt.NDArray[np.complex128] | None = None
        """The Fresnel transmission coefficients with roughness for each energy, angle and interface (L, M, N)"""
        # Call the parent constructor
        super().__init__()

    def reset(self):
        """
        Clear/initialise the result object attributes to None.
        """
        self.z_roughness = None
        self.rough_S = None
        self.rough_T = None
        self.fresnel_r_rough = None
        self.fresnel_t_rough = None
        # Reset the parent properties
        super().reset()


def XEF(
    energies: list[float] | npt.NDArray[np.floating] | float,
    angles: list[float] | npt.NDArray[np.floating] | float,
    z: list[float] | npt.NDArray[np.floating],
    refractive_indices: (
        list[complex]
        | npt.NDArray[np.complexfloating]
        | list[Callable]
        | list["asp_complex"]
    ),
    z_roughness: list[float] | npt.NDArray[np.floating] | None = None,
    *,
    layer_names: list[str] | None = None,
    input_checking: bool = True,
    generate_figure: bool = False,
) -> BasicResult | BasicRoughResult:
    """
    Calculate the complex X-ray Electric Field for a set of layers.

    Parameters
    ----------
    beam_energy : list[float] | npt.NDArray[np.floating] | float
        The beam energy(s) in eV. Can be a single value or an array of values.
    angles : list[float] | npt.NDArray[np.floating] | float
        The angles in degrees at which to calculate the XEFI. Can be a single value or an array of values.
    z : list[float] | npt.NDArray[np.floating]
        The interface locations in Angstroms. Must be a list or array of floats.
    refractive_indices : list[complex] | npt.NDArray[np.complexfloating] | list[Callable] | list["asp_complex"]
        The refractive indices for each energy and layer. 
        Can be a list of complex numbers (L, N+1), a numpy array of complex numbers (L, N+1),
        a list of `KKCalc` `asp_complex` objects (N+1), or a list of Callable functions that return complex numbers (N+1).
    z_roughness : list[float] | npt.NDArray[np.floating] | None, optional
        The roughness of the interfaces in Angstroms. If provided, it should be a list or array of floats with the same length as `z`.
        If None, no roughness is applied, by default None.
    layer_names : list[str] | None, optional
        The names of the layers corresponding to the refractive indices, by default None.
    input_checking : bool, optional
        Whether to perform input checking, by default True.
    generate_figure : bool, optional
        Whether to generate a figure of the XEFI, by default False.

    Returns
    -------
    BasicResult | BasicRoughResult
        An instance of BasicResult or BasicRoughResult containing the calculated XEFI data.
        A BasicRoughResult is returned if `z_roughness` is provided, otherwise a BasicResult is returned.
    """
    # Initialise a result
    result = BasicRoughResult() if z_roughness is not None else BasicResult()

    ## Collect the properties
    # Beam energy
    energies = np.atleast_1d(energies)
    """The beam energy(s) in eV (with length L)"""
    result.energies = energies
    # Energy number
    L: int = energies.shape[0]
    """Number of energies."""
    result.L = L
    # Angles
    angles = np.atleast_1d(angles)
    theta = np.deg2rad(angles)
    """The angles in radians (with length M)"""
    result.theta = theta
    # Angle number
    M: int = angles.shape[0]
    """Number of angles."""
    result.M = M
    # Interface locations
    z = np.asarray(z, dtype=np.float64, copy=True)
    result.z = z
    # Interface number
    N: int = z.shape[0]
    """Number of interfaces N."""
    result.N = N
    # Labels
    if layer_names is not None:
        assert len(layer_names) == N + 1, "Layer names must match the number of layers (N+1)."
        result.layer_names = layer_names.copy()
    else:
        result.layer_names = None

    # Roughness
    if z_roughness is not None:
        z_roughness = np.asarray(z_roughness, dtype=np.float64, copy=True)
        assert z_roughness.ndim == 1
        result.z_roughness = z_roughness
    else:
        result.z_roughness = None

    # Refractive indices require verification based on supplied data type
    ref_idxs: npt.NDArray[np.complexfloating]
    """A numpy array of complex refractive indices across all energies (L) and layers (N)."""
    if (
        isinstance(refractive_indices, np.ndarray)
        and L > 1
        and refractive_indices.ndim == 2
        and refractive_indices.shape[1] == N + 1
        and refractive_indices.shape[0] == L
    ):
        # Valid refractive indices for multiple energies
        if issubclass(refractive_indices.dtype.type, np.complexfloating):
            ref_idxs = refractive_indices.copy()
        else:
            raise ValueError(
                f"Refractive indices must be a numpy array of complex numbers \
                              for multiple energies. Dtype was instead {refractive_indices.dtype}"
            )

    elif (
        isinstance(refractive_indices, np.ndarray)
        and L == 1
        and refractive_indices.ndim == 1
        and refractive_indices.shape[0] == N + 1
    ):
        # Valid refractive indices for a single energy
        if issubclass(refractive_indices.dtype.type, np.complex128):
            ref_idxs = refractive_indices.copy()
        else:
            raise ValueError(
                f"Refractive indices must be a numpy array of complex numbers \
                                for a single energy. Dtype was instead {refractive_indices.dtype}"
            )

    elif (
        isinstance(refractive_indices, list)
        and all(isinstance(n, (int, float, complex)) for n in refractive_indices)
        and L == 1
        and len(refractive_indices) == N + 1
    ):
        # Valid refractive indices for a single energy
        ref_idxs = np.asarray(refractive_indices, dtype=np.complex128, copy=True)
        if sum(ref_idxs.imag != 0) == 0:
            warnings.warn(
                "Refractive indices provided are all real. \
                This may not be correct for X-ray calculations.",
                UserWarning,
            )
    elif (
        isinstance(refractive_indices, (list, np.ndarray))
        and has_KKCalc
        # Allow float for vacuum or air - i.e. no material absorption.:
        and all(isinstance(n, (float, complex, asp_complex)) for n in refractive_indices)
        and len(refractive_indices) == N + 1
    ):
        # Valid refractive indices for a single energy using KKCalc
        ref_idxs = np.zeros((L, N + 1), dtype=np.complex128)
        for i, mat_n in enumerate(
            refractive_indices
        ):  # Iterate over the layers, apply the energy.
            if isinstance(mat_n, asp_complex):
                ref_idxs[:, i] = mat_n.eval_refractive_index(
                    energies
                )  # Apply the energy to the KKCalc object
            elif isinstance(mat_n, complex):
                ref_idxs[:, i] = mat_n
            else: # float
                ref_idxs[:, i] = mat_n + 0j  # Convert to complex

    elif (
        isinstance(refractive_indices, list) 
        and len(refractive_indices) == N + 1
        and all(callable(n) for n in refractive_indices)
    ):
        # Valid refractive indices for multiple energies using Callable
        ref_idxs = np.zeros((L, N + 1), dtype=np.complex128)
        single_energy_calc: bool = (
            False  # Prevent callable from being called with multiple energies.
        )
        for i, mat_n in enumerate(
            refractive_indices
        ):  # Iterate over the layers, apply the energy.
            assert callable(mat_n)
            if L == 1:
                ref_idxs[0, i] = mat_n(
                    energies
                )  # Apply the energy to the Callable function
            elif single_energy_calc:
                for j in range(L):
                    ref_idxs[j, i] = mat_n(
                        energies[j]
                    )  # Apply the energy to the Callable function
            else:
                if callable(mat_n):
                    try:
                        ref_idxs[:, i] = mat_n(
                            energies
                        )  # Apply the energy to the Callable function
                    except TypeError | ValueError as e:
                        single_energy_calc = True
                        for j in range(L):
                            ref_idxs[j, i] = mat_n(
                                energies[j]
                            )  # Apply the energy to the Callable function

    else:
        raise ValueError(
            "Refractive index values must be a list of complex numbers, \
                            a numpy array of complex numbers, a list of `KKCalc` `asp_complex` objects \
                            or a list of Callable functions for multiple energies."
        )
        
    ## Generate result data
    # Wavevector magnitude in vacuum
    k0: npt.NDArray[np.floating] = en2wvec * energies # convert energy to wavevector.
    """The wavevector magnitude (per Å) in vacuum for each energy (L)."""
    result.k0 = k0

    # Wavevector-z in each layer
    wavevectors: npt.NDArray[np.complexfloating] = np.zeros(
        (L, M, N + 1), dtype=np.complex128
    )
    """Z-component wavevectors at each energy (L) and angle (M) for each layer (N + 1)."""
    wavevectors[:, :, 0] = -k0[:, np.newaxis] * np.sin(theta[np.newaxis, :])

    # Angle of incidence in each layer
    angles_of_incidence: npt.NDArray[np.complexfloating] = np.zeros(
        (L, M, N + 1), dtype=np.complex128
    )
    angles_of_incidence[:, :, 0] = theta[
        np.newaxis, :
    ]  # Vacuum layer has no refraction

    # Calculate angles of incidence for each layer: Snell's Law
    angles_of_incidence[:, :, 1:] = np.arccos(
        np.cos(theta[np.newaxis, :, np.newaxis])
        * ref_idxs[:, np.newaxis, 0]
        / ref_idxs[:, np.newaxis, 1:]
    )
    # Calculate wavevectors for each layer
    wavevectors[:, :, 1:] = -k0[:, np.newaxis, np.newaxis] * np.sqrt(
        ref_idxs[:, np.newaxis, 1:] ** 2 - np.cos(theta[np.newaxis, :, np.newaxis]) ** 2
    )
    # Small angle approximation for cosine:
    # wavevectors[:, :, 1:] = k0[:, np.newaxis, np.newaxis] * angles_of_incidence[:, :, 1:]

    fig, ax = plt.subplots(2, 1, sharex=True)
    for i in range(L):
        for j in range(N):
            ax[0].plot(angles, wavevectors[i, :, j].real, label=f"Interface {j,j+1}")
            ax[1].plot(angles, wavevectors[i, :, j].imag, label=f"Interface {j,j+1}")
    ax[0].set_ylabel("Wavevector Re")
    ax[1].set_ylabel("Wavevector Im")
    ax[1].set_xlabel("Angle (degrees)")

    result.wavevectors = wavevectors
    result.angles_of_incidence = angles_of_incidence

    # Calculate the Fresnel coefficients for each layer
    fresnel_r = np.zeros((L, M, N), dtype=np.complex128)
    """The Fresnel reflection coefficients for each interface (L, M, N)"""
    fresnel_t = np.zeros((L, M, N), dtype=np.complex128)
    """The Fresnel transmission coefficients for each interface (L, M, N)"""
    fresnel_t[:, :, :] = (
        2 * wavevectors[:, :, :-1] / (wavevectors[:, :, :-1] + wavevectors[:, :, 1:])
    )
    fresnel_r[:, :, :] = fresnel_t[:, :, :] - 1.0
    # fresnel_r[:, :, :] = (
    #     (wavevectors[:, :, :-1] - wavevectors[:, :, 1:]) /
    #     (wavevectors[:, :, :-1] + wavevectors[:, :, 1:])
    # )
    result.fresnel_r = fresnel_r
    result.fresnel_t = fresnel_t
    
    fig,ax = plt.subplots(2,1, sharex=True)
    for l in range(L):
        for i in range(N):
            ax[0].plot(angles, fresnel_r[l, :, i].real, label="Fr R (Re) " + layer_names[i+1])
            ax[1].plot(angles, fresnel_r[l, :, i].imag, label="Fr R (Im) " + layer_names[i+1])
            ax[0].plot(angles, fresnel_t[l, :, i].real, label="Fr T (Re) " + layer_names[i+1])
            ax[1].plot(angles, fresnel_t[l, :, i].imag, label="Fr T (Im) " + layer_names[i+1])
    ax[1].set_xlabel("Angle (degrees)")
    ax[0].set_ylabel("Fresnel Coefficients (Re)")
    ax[1].set_ylabel("Fresnel Coefficients (Im)")
    ax[0].legend()
    ax[1].legend()
    plt.show()

    # Calculate the critical angles
    critical_angles: npt.NDArray[np.floating] = np.sqrt(2 * (1 - ref_idxs[:, 1:].real))
    """The critical angles of each energy and material interface (excluding vacuum/air) (L, N)"""
    result.critical_angles = critical_angles

    # Calculate the field strenghts, using roughness contributions if provided
    X = np.zeros((L, M, N+1), dtype=np.complex128)
    """The ratio of the field strengths within each layer (L, M, N+1). 
    For the substrate layer X[N+1]=0."""
    # """The ratio of the field strengths for each layer calculated at the top interface (L, M, N+1), 
    # with an additional `bottom substrate` layer where X[N+1]=0."""
    R = np.zeros((L, M, N+1), dtype=np.complex128)
    """The reflection field strengths for each layer calculated at the top interface (L, M, N+1),
    with an additional `bottom substrate` layer where R[N+1]=0"""
    T = np.zeros((L, M, N+1), dtype=np.complex128)
    """The transmission field strengths for each layer calculated at the top interface (L, M, N+1),
    with an additional `bottom substrate` layer where T[N+1]!=0"""
    T[:, :, 0] = 1.0  # Vacuum layer has no transmission
    if z_roughness is not None:
        raise ValueError("Not working yet.")
        assert isinstance(result, BasicRoughResult)
        
        # Roughness factors:
        rr_S: npt.NDArray[np.complex128] = np.exp(
            -2
            * z_roughness[np.newaxis, np.newaxis, :] ** 2
            * wavevectors[:, :, :-1]
            * wavevectors[:, :, 1:]
        )
        """Roughness reflection factor for each interface (L, M, N)"""
        rr_T: npt.NDArray[np.complex128] = np.exp(
            -2
            * z_roughness[np.newaxis, np.newaxis, :] ** 2
            * (wavevectors[:, :, :-1] + wavevectors[:, :, 1:]) ** 2
        )
        """Roughness transmission factor for each interface (L, M, N)"""

        fresnel_r_rough: npt.NDArray[np.complex128] = fresnel_r * rr_S
        """The Fresnel reflection coefficients with roughness for each interface (L, M, N)"""
        fresnel_t_rough: npt.NDArray[np.complex128] = fresnel_t * rr_T
        """The Fresnel transmission coefficients with roughness for each interface (L, M, N)"""

        # Store the roughness results in the result object
        result.rough_S = rr_S
        result.rough_T = rr_T
        result.fresnel_r_rough = fresnel_r_rough
        result.fresnel_t_rough = fresnel_t_rough

        # Recursively calculate the ratio of the field strengths
        for i in range(N - 1, -1, -1):
            d_jp1 = abs(z[i + 2] - z[i + 1]) if i < N - 2 else 0
            """The thickness of the layer below interface j+1"""
            a_jp1 = (
                np.exp(1j * wavevectors[:, :, i] * d_jp1)
                if i < N - 1
                else 0.0  # at i+1 = N, semi-infinite X_{N} = 0.
            )
            X[:, :, i] = (
                (fresnel_r_rough[:, :, i] + a_jp1**2 * X[:, :, i + 1])
                / (1 + a_jp1**2 * X[:, :, i+1] * fresnel_r_rough[:, :, i])
                if i != N - 1
                else fresnel_r_rough[:, :, i] # when X_N = R_N = 0
            )
        result.X = X

        # Calculate the field strengths
        for i in range(0, N-1):
            d_j = abs(z[i + 1] - z[i]) if (i < N - 1) else 0
            d_jp1 = abs(z[i + 2] - z[i + 1]) if i < N - 2 else 0
            a_j = np.exp(1j * wavevectors[:, :, i] * d_j) if i < N else 0.0
            a_jp1 = (
                np.exp(1j * wavevectors[:, :, i] * d_jp1)
                if i < N - 1
                else 0.0  # at i+1 = N, semi-infinite X_N = 0.0
            )
            
            T[:, :, i + 1] = (a_j * T[:, :, i] * fresnel_t_rough[:, :, i]) / (
                1 + a_jp1**2 * X[:, :, i + 1] * fresnel_r_rough[:, :, i]
            )
            
            R[:, :, i] = a_j**2 * X[:, :, i] * T[:, :, i]
        result.R = R
        result.T = T
    else:
        # Calculate X below the ith interface..
        # X[N-1] = 0 as the initial condition.
        # Start from the second last slab.
        for i in range(N-1, -1, -1): # i=interface
            j = i+1 # wavevector slab index
            
            # # DEV
            # d_jp1 = abs(z[i + 2] - z[i + 1]) if j < N - 2 else 0
            # """The thickness of the layer below interface i+1"""
            # a_jp1 = (
            #     np.exp(-1j * wavevectors[:, :, j+1] * d_jp1)
            # )
            # X[:, :, i] = (
            #     (fresnel_r[:, :, i] + a_jp1**2 * X[:, :, i + 1])
            #     / (1 + a_jp1**2 * X[:, :, i + 1] * fresnel_r[:, :, i])
            # )
            
            # TOLAN
            a_jp1 = X[:, :, i + 1] * np.exp(-2j * wavevectors[:, :, j] * z[i])
            X[:, :, i] = np.exp(2j * wavevectors[:, :, i] * z[i]) * (
                (fresnel_r[:, :, i] + a_jp1)
                / (1 + fresnel_r[:, :, i] * a_jp1)
            ) if i < N else fresnel_r[:,:,i] * np.exp(2j * wavevectors[:, :, i] * z[i]) # at i = N-1, semi-infinite X_N+1 = 0.0
            
            # print(f"Layer {i}: X = {X[0,5,i]}, \t a_jp1 = {a_jp1}, \t fresnel_r = {fresnel_r[0, 5, i]} \t djp1 = {d_jp1}")
        result.X = X

        # Calculate the field strengths at the ith interface.
        R[:,:,0] = X
        for i in range(0, N-1):
            # DEV
            # d_j = z[i + 1] - z[i] if (i < N - 1) else 0
            # d_jp1 = z[i + 2] - z[i + 1] if i < N - 2 else 0
            # a_j = np.exp(-1j * wavevectors[:, :, i+1] * d_j)
            # a_jp1 = (
            #     np.exp(-1j * wavevectors[:, :, i+2] * d_jp1)
            #     if i < N - 1
            #     else 0.0  # at i+1 = N, semi-infinite X_N = 0.0
            # )
            
            # T[:, :, i + 1] = (
            #     (a_j * T[:, :, i] * fresnel_t[:, :, i]) / (
            #     1 + a_jp1**2 * X[:, :, i + 1] * fresnel_r[:, :, i])
            # )
            # R[:, :, i] = a_j**2 * X[:, :, i] * T[:, :, i]
            
            # TOLAN
            wv_diff = wavevectors[:, :, i+1] - wavevectors[:, :, i]
            wv_add = wavevectors[:, :, i+1] + wavevectors[:, :, i]
            R[:,:,i+1] = (
                1/(fresnel_t[:, :, i]) * (
                    T[:,:,i] * fresnel_r[:,:,i] * np.exp(1j * (wv_add) * z[i])
                    + R[:,:,i] * np.exp(1j * (wv_diff) * z[i])
                )
            )
            T[:,:,i+1] = (
                1/(fresnel_t[:, :, i]) * (
                    T[:,:,i] * np.exp(-1j * (wv_diff) * z[i])
                    + R[:,:,i] * fresnel_r[:,:,i] * np.exp(-1j * (wv_add) * z[i])
                )
            )
            
        result.R = R
        result.T = T

    fig,ax = plt.subplots(3,1, sharex=True, figsize=(10,8))
    if L == 1:
        for i in range(N):
            ax[0].plot(angles, np.abs(result.R[0, :, i])**2, label = layer_names[i+1])
            ax[1].plot(angles, np.abs(result.T[0, :, i])**2, label = layer_names[i+1])
            ax[2].plot(angles, np.abs(result.X[0, :, i])**2, label = layer_names[i+1])

    if L == 1:
        for i in range(N):
            for l in range(3):
                # Add vertical line
                ax[l].axvline(x=np.rad2deg(critical_angles[0, i]), color='k', linestyle='--')
                ax[l].set_ylim(1e-3, 2.0)

    ax[0].set_yscale("log")
    ax[1].set_yscale("log")
    ax[2].set_yscale("log")
    ax[-1].set_xlabel("Angle (degrees)")
    ax[0].set_ylabel("Reflectance")
    ax[1].set_ylabel("Transmittance")
    ax[2].set_ylabel("Field Strength")
    ax[0].legend()

    # Finishing up - reduce dimensions if L or M is 1.
    result.X = np.squeeze(X)[()]
    result.R = np.squeeze(R)[()]
    result.T = np.squeeze(T)[()]
    result.wavevectors = np.squeeze(wavevectors)[()]
    result.angles_of_incidence = np.squeeze(angles_of_incidence)[()]
    result.refractive_indices = np.squeeze(ref_idxs)[()]
    result.critical_angles = np.squeeze(critical_angles)[()]

    # Return the result
    return result
